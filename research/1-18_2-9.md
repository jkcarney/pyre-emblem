# Developing a Model of the Enviornment for Fire Emblem: The Blazing Blade

## Simplications

For brevity sake, I'll simplify some of the rules of Fire Emblem to make RL simplier:

- Weapon and staff durability is a non concern; they effectively will have âˆž durability. The only items that can be broken are consumables such as vulneraries or elixers.
- No unit support bonuses in combat.
- No S rank bonuses for weapons in combat.
- No tactician bonus in combat
- Agents are limited to 3 actions after moving:
  - Attack (if valid)
  - Item (if valid)
  - Wait
- Typically maps in Fire Emblem can have varying goals. For example, some objectives are to route all enemies, some are to capture a certain point, some are to survive until a turn count...
  - Let's just get rid of all those conditions and just say the goal of every map is to route all enemies. That typically will move the game towards the goal anyways in most conditions. 
- No EXP / WEXP / level gain will be gotten. 
- Weapon experience is not relevant
- Maps with weather effects will not be considered.
- Maps with fog of war will not be considered
- Maps that typically have a outdoor structure with mountains/plains/forests will exclusively be considered and tested on

## Structure of a Unit

Based on the underlying memory representation of a unit, we can make a guess about how a unit is represented as a "struct" in memory (if we theorize that the GBA games were written in a C like language, or C)

We can also analyze old posts on forums such as the GameFAQs (https://gamefaqs.gamespot.com/gba/468480-fire-emblem/faqs/31542) that contain memory addresses for things such as cheat codes in order to infer how units are represented:

```C
struct Unit
{
    int portraitCode;
    int classCode;
    int level;
    int experience;
    int horizontalPosition;
    int verticalPosition;

    int maxHP;
    int currentHP;
    int strength;
    int skill;
    // .. Other stats such as speed

    struct Inventory inventory;

    // .. other stuff
};

```

We need to translate this into a Python unit class that hold all this information with some extra stuff needed

```python
class Unit:
    def __init__(self, character_code, x, y, level, job_code, hp_max,
                 strength, skill, spd, luck, defense, res, magic, ally,
                 inventory_codes: list, terminal_condition):
        self.terminal_condition = terminal_condition

        self.character_code = character_code
        self.x = x
        self.y = y
        self.level = level
        self.hp_max = hp_max
        self.current_hp = hp_max
        self.strength = strength
        self.magic = magic
        self.skill = skill
        self.speed = spd
        self.luck = luck
        self.defense = defense
        self.res = res

        self.inventory = item.construct_unit_inventory(inventory_codes)

        self.name = feutils.character_name_table(self.character_code)
        self.job = feutils.class_table(job_code)
        self.move = feutils.movement_table(self.job)
        self.terrain_group = feutils.job_terrain_group(self.job)

        if ally:
            self.con = feutils.character_constitution_table(self.name)
        else:
            self.con = feutils.job_constitution_table(self.job)
```
Most of these are self explanatory. Some clarifications:

`self.terminal_condition` - Sets if the unit is a "terminal condition" unit. A **terminal condition unit** is defined as a unit that, upon death, causes an instant loss for their associated team. In game, this typically functions as a loss condition for the "allies" team - if one of the main characters such as Lyn, Eliwood, or Hector dies, then it results in an immediate game over. 

`self.inventory` - A list of items that the unit currently has on them. Includes weapons and consumables. 

`self.move` - The maximum manhattan distance that this unit can travel on the board. This will be important in figuring out where the unit can move on a given map.

`self.terrain_group` - Detemines the unit's **terrain group**, which is used to determine how much certain tiles cost to move through. 

## Lookup Tables

There are... a lot of lookup tables. Mainly for translating bytes into usable dictionaries for Python. These are defined in `feutils.py` and the `jsons/` folder in the root of the repository. Mainly for terrain data, item data, weapon data, unit name/class data, etc. 

## Map Generation

Fire Emblem 7 has over 32 unique maps used throughout the game. This number is not sufficient to train a diversely trained RL agent without overfitting. It would be much better to generate maps for training data that are randomly populated with terrain and enemies in a reasonable way.

### Terrain

There are a few terrain generation algorithms out there we could use to generate the terrain data. For simplicity sake, let's use Conway's Game of Life alogrithm. https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life This is easy to implement, fairly performative, and generates reasonable maps. `map_factory.py` contains the relevnant code to generate a map. 

```python
class OutdoorMapFactory:
    """
    Generates an outdoor style map utilizing 3 map layer factories and combines them
    """
    def __init__(self, x_min, x_max, y_min, y_max):
        self.x_min, self.x_max = x_min, x_max
        self.y_min, self.y_max = y_min, y_max

        self.grass_water_factory = MapLayerFactory(5, 2, 7, 3, 8)
        self.forest_factory = MapLayerFactory(4, 2, 6, 4, 7)
        self.mountain_factory = MapLayerFactory(2, 3, 8, 3, 8)
```

First we generate a factory object that contains MapLayerFactory objects. These MapLayerFactorys generate individual components of the maps, namely the grass/water, forests, and mountains.

We call the `generate_map` function to utilize these three factories to generate binary maps, and then combine them according to some basic rules:

```python
# in map_factory.generate_map:

for i in range(x):
    for j in range(y):
        #Alive represents lake, dead represents plains
        if grass_water_grid[i, j]:
            final_map[i, j] = 'Lake'
            number_map[i, j] = 1
        else:
            final_map[i, j] = 'Plain'
            number_map[i, j] = 0

        if final_map[i, j] == 'Plain' and forest_grid[i, j]:
            final_map[i, j] = 'Forest'
            number_map[i, j] = 2

        if final_map[i, j] != 'Lake' and mountain_grid[i, j]:
            final_map[i, j] = 'Mountain'
            number_map[i, j] = 3

return Map(x, y, final_map), number_map
```

This generates nice looking maps that could *reasonably* be found in a Fire Emblem game.

(Brown tiles represent mountains; Blue tiles represent water; light green tiles represent grass/plains; dark green tiles represent forest)

<img src="images/map1.png" alt="Map1" height="150" width="200"/>

<img src="images/map2.png" alt="Map2" height="150"   width="200"/>

<img src="images/map3.png" alt="Map3" height="150"   width="200"/>

### Unit placement

todo

## Combat Simulation

Now that we can generate maps as well as unit representation, we can run combat simulations. Most formulas have been taken from https://serenesforest.net/blazing-sword/miscellaneous/calculations/ with the simplifications mentioned above. 


<i><p align="center">Unit's Attack Speed</p></i>
<b><p align="center">AS = S - max((W - C), 0)</p></b>
<p align="center">Where<br> S = Unit Speed Stat,<br>W = Equipped weapon weight,<br>C = Unit Constitution Stat</p>
<br>
<i><p align="center">Weapon and Magic Triangle</p></i>
<b><p align="center">Sword > Axe > Lance > Sword</p></b>
<b><p align="center">Anima > Light > Dark > Anima</p></b>
<p align="center">Where '>' means 'is good against'</p>
<p align="center">Positive weapon bonuses get +15%/+1 avoid/def bonus</p>
<p align="center">Negative weapon bonuses get -15%/-1 avoid/def bonus</p>
<br>
